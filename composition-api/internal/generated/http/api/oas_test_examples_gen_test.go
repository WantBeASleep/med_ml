// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCard_EncodeDecode(t *testing.T) {
	var typ Card
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Card
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCard_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"diagnosis\":\"опухоль\",\"doctor_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"patient_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Card

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Card
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestContor_EncodeDecode(t *testing.T) {
	var typ Contor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContorItem_EncodeDecode(t *testing.T) {
	var typ ContorItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContorItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevice_EncodeDecode(t *testing.T) {
	var typ Device
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Device
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDevice_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1,\"name\":\"ульпанатор 3000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Device

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Device
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDoctor_EncodeDecode(t *testing.T) {
	var typ Doctor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Doctor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDoctor_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Doctor

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Doctor
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEchographics_EncodeDecode(t *testing.T) {
	var typ Echographics
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Echographics
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEchographics_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"additional\":\"видны последстввия нездорового образа жизни\",\"conclusion\":\"требуется лечение\",\"contors\":\"контуры\",\"echogenicity\":\"эхогенность\",\"gland_volum\":100,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"isthmus\":100,\"left_lobe_length\":100,\"left_lobe_thick\":100,\"left_lobe_volum\":100,\"left_lobe_width\":100,\"location\":\"в правой части\",\"regional_lymph\":\"в правой части\",\"right_lobe_length\":100,\"right_lobe_thick\":100,\"right_lobe_volum\":100,\"right_lobe_width\":100,\"struct\":\"квадрат\",\"vascularization\":\"выраженная\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Echographics

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Echographics
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImage_EncodeDecode(t *testing.T) {
	var typ Image
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Image
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestImage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"page\":1,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Image

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Image
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLoginPostOK_EncodeDecode(t *testing.T) {
	var typ LoginPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginPostReq_EncodeDecode(t *testing.T) {
	var typ LoginPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLoginPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"test@test.com\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ LoginPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 LoginPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMedCardDoctorIDPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedCardDoctorIDPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedCardDoctorIDPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedDoctorIDPatientsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ MedDoctorIDPatientsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedDoctorIDPatientsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientPostReq_EncodeDecode(t *testing.T) {
	var typ MedPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNode_EncodeDecode(t *testing.T) {
	var typ Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":true,\"description\":\"узел явно неправильный\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Node

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Node
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNodeValidation_EncodeDecode(t *testing.T) {
	var typ NodeValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatient_EncodeDecode(t *testing.T) {
	var typ Patient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Patient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPatient_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"birth_date\":\"2021-01-01\",\"email\":\"ivan@example.com\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"last_uzi_date\":\"2024-01-01\",\"malignancy\":false,\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Patient

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Patient
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPaymentProvider_EncodeDecode(t *testing.T) {
	var typ PaymentProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPaymentProvider_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"is_active\":true,\"name\":\"Yookassa\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PaymentProvider

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PaymentProvider
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPaymentProvidersGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PaymentProvidersGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentProvidersGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPurchaseSubscriptionRequest_EncodeDecode(t *testing.T) {
	var typ PurchaseSubscriptionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PurchaseSubscriptionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPurchaseSubscriptionRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"payment_provider_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tariff_plan_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PurchaseSubscriptionRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PurchaseSubscriptionRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPurchaseSubscriptionResponse_EncodeDecode(t *testing.T) {
	var typ PurchaseSubscriptionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PurchaseSubscriptionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPurchaseSubscriptionResponse_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"confirmation_url\":\"https://example.com/confirm\",\"subscription_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PurchaseSubscriptionResponse

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PurchaseSubscriptionResponse
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRefreshPostOK_EncodeDecode(t *testing.T) {
	var typ RefreshPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRefreshPostReq_EncodeDecode(t *testing.T) {
	var typ RefreshPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRefreshPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"refresh_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RefreshPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RefreshPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegDoctorPostReq_EncodeDecode(t *testing.T) {
	var typ RegDoctorPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegDoctorPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegDoctorPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegDoctorPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegDoctorPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegPatientPostReq_EncodeDecode(t *testing.T) {
	var typ RegPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegPatientPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"birth_date\":\"2021-01-01\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"password\":\"qwerty123\",\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegPatientPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegPatientPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSegment_EncodeDecode(t *testing.T) {
	var typ Segment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Segment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSegment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":false,\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"image_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"node_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.45,\"tirads_4\":0.78,\"tirads_5\":0.12}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Segment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Segment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSimpleUuid_EncodeDecode(t *testing.T) {
	var typ SimpleUuid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleUuid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSimpleUuid_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SimpleUuid

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SimpleUuid
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubscription_EncodeDecode(t *testing.T) {
	var typ Subscription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Subscription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSubscription_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"end_date\":\"2023-12-31T23:59:59Z\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"start_date\":\"2023-01-01T00:00:00Z\",\"status\":\"active\",\"tariff_plan_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Subscription

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Subscription
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubscriptionStatus_EncodeDecode(t *testing.T) {
	var typ SubscriptionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionsCheckActiveGetOK_EncodeDecode(t *testing.T) {
	var typ SubscriptionsCheckActiveGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionsCheckActiveGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTariffPlan_EncodeDecode(t *testing.T) {
	var typ TariffPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TariffPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTariffPlan_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"This is a basic tariff plan.\",\"duration\":2592000000000000,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"name\":\"Basic Plan\",\"price\":\"9.99\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TariffPlan

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TariffPlan
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTariffPlansGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ TariffPlansGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TariffPlansGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzi_EncodeDecode(t *testing.T) {
	var typ Uzi
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Uzi
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUzi_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"checked\":false,\"create_at\":\"2021-01-01T00:00:00Z\",\"device_id\":1,\"external_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"projection\":\"cross\",\"status\":\"pending\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Uzi

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Uzi
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostOK_EncodeDecode(t *testing.T) {
	var typ UziDevicePostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostReq_EncodeDecode(t *testing.T) {
	var typ UziDevicePostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Siemens\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziDevicesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDImagesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDImagesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDImagesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDNodesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostOK_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReq_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqNode_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqSegmentsItem_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqSegmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqSegmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"checked\":true,\"projection\":\"cross\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziIDPatchReqProjection_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReqProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReqProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziImageIDNodesSegmentsGetOK_EncodeDecode(t *testing.T) {
	var typ UziImageIDNodesSegmentsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziImageIDNodesSegmentsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziNodesIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziNodesIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziNodesIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziNodesIDPatchReqValidation_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReqValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReqValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDSegmentsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziNodesIDSegmentsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDSegmentsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziProjection_EncodeDecode(t *testing.T) {
	var typ UziProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziSegmentIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziSegmentIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziSegmentIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziSegmentIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziSegmentPostReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziStatus_EncodeDecode(t *testing.T) {
	var typ UziStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisAuthorIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisAuthorIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisAuthorIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisExternalIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisExternalIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisExternalIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequest_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestYookassaWebhookRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"event\":\"payment.waiting_for_capture\",\"object\":{\"amount\":{\"currency\":\"RUB\",\"value\":\"2.00\"},\"created_at\":\"2018-07-10T14:27:54.691Z\",\"description\":\"Заказ №72\",\"expires_at\":\"2018-07-17T14:28:32.484Z\",\"id\":\"22d6d597-000f-5000-9000-145f6df21d6f\",\"metadata\":{},\"paid\":true,\"payment_method\":{\"card\":{\"card_type\":\"MasterCard\",\"expiry_month\":\"07\",\"expiry_year\":\"2021\",\"first6\":\"555555\",\"issuer_country\":\"RU\",\"issuer_name\":\"Sberbank\",\"last4\":\"4444\"},\"id\":\"22d6d597-000f-5000-9000-145f6df21d6f\",\"saved\":false,\"type\":\"bank_card\"},\"refundable\":false,\"status\":\"waiting_for_capture\",\"test\":false},\"type\":\"notification\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ YookassaWebhookRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 YookassaWebhookRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestYookassaWebhookRequestObject_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectAmount_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectAmount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectAmount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectMetadata_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectPaymentMethod_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectPaymentMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectPaymentMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestYookassaWebhookRequestObjectPaymentMethodCard_EncodeDecode(t *testing.T) {
	var typ YookassaWebhookRequestObjectPaymentMethodCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 YookassaWebhookRequestObjectPaymentMethodCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
