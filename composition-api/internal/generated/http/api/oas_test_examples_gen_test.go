// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestContor_EncodeDecode(t *testing.T) {
	var typ Contor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContorItem_EncodeDecode(t *testing.T) {
	var typ ContorItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContorItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevice_EncodeDecode(t *testing.T) {
	var typ Device
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Device
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDevice_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1,\"name\":\"ульпанатор 3000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Device

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Device
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEchographics_EncodeDecode(t *testing.T) {
	var typ Echographics
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Echographics
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEchographics_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"additional\":\"пьет курит и ебет\",\"conclusion\":\"грустно\",\"contors\":\"контуры\",\"echogenicity\":\"эхогенность\",\"gland_volum\":100,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"isthmus\":100,\"left_lobe_length\":100,\"left_lobe_thick\":100,\"left_lobe_volum\":100,\"left_lobe_width\":100,\"location\":\"в правой части\",\"regional_lymph\":\"в правой части\",\"right_lobe_length\":100,\"right_lobe_thick\":100,\"right_lobe_volum\":100,\"right_lobe_width\":100,\"struct\":\"квадрат блять\",\"vascularization\":\"выраженная\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Echographics

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Echographics
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImage_EncodeDecode(t *testing.T) {
	var typ Image
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Image
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestImage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"page\":1,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Image

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Image
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNode_EncodeDecode(t *testing.T) {
	var typ Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":false,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Node

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Node
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSegment_EncodeDecode(t *testing.T) {
	var typ Segment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Segment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSegment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"image_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"node_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.45,\"tirads_4\":0.78,\"tirads_5\":0.12}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Segment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Segment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSimpleUuid_EncodeDecode(t *testing.T) {
	var typ SimpleUuid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleUuid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSimpleUuid_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SimpleUuid

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SimpleUuid
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUzi_EncodeDecode(t *testing.T) {
	var typ Uzi
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Uzi
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUzi_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"checked\":false,\"create_at\":\"2021-01-01T00:00:00Z\",\"device_id\":1,\"external_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"projection\":\"задняя крутая\",\"status\":\"pending\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Uzi

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Uzi
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostOK_EncodeDecode(t *testing.T) {
	var typ UziDevicePostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostReq_EncodeDecode(t *testing.T) {
	var typ UziDevicePostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Siemens\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziDevicesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDImagesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDImagesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDImagesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDNodesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"checked\":true,\"projection\":\"52 улица\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziImageIDNodesSegmentsGetOK_EncodeDecode(t *testing.T) {
	var typ UziImageIDNodesSegmentsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziImageIDNodesSegmentsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziNodesIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziNodesIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziNodesIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziNodesIDSegmentsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziNodesIDSegmentsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDSegmentsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesSegmentsPostOK_EncodeDecode(t *testing.T) {
	var typ UziNodesSegmentsPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesSegmentsPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesSegmentsPostReq_EncodeDecode(t *testing.T) {
	var typ UziNodesSegmentsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesSegmentsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesSegmentsPostReqNode_EncodeDecode(t *testing.T) {
	var typ UziNodesSegmentsPostReqNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesSegmentsPostReqNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesSegmentsPostReqSegmentsItem_EncodeDecode(t *testing.T) {
	var typ UziNodesSegmentsPostReqSegmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesSegmentsPostReqSegmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziSegmentIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziSegmentIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziSegmentIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziSegmentIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziSegmentPostReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziStatus_EncodeDecode(t *testing.T) {
	var typ UziStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisExternalIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisExternalIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisExternalIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
