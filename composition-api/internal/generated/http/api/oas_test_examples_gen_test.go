// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCard_EncodeDecode(t *testing.T) {
	var typ Card
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Card
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCard_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"diagnosis\":\"опухоль\",\"doctor_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"patient_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Card

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Card
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChat_EncodeDecode(t *testing.T) {
	var typ Chat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Chat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChat_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2021-01-01T00:00:00Z\",\"description\":\"Discussion about UZI results\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"name\":\"Consultation about UZI\",\"participant_ids\":[\"123e4567-e89b-12d3-a456-426614174001\",\"123e4567-e89b-12d3-a456-426614174002\"],\"patient_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Chat

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Chat
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChatsChatidHistoryGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ChatsChatidHistoryGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatsChatidHistoryGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ChatsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChatsPostReq_EncodeDecode(t *testing.T) {
	var typ ChatsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChatsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChatsPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"Discussion about UZI results\",\"name\":\"Consultation about UZI\",\"participant_ids\":[\"123e4567-e89b-12d3-a456-426614174001\"],\"patient_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChatsPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChatsPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestContor_EncodeDecode(t *testing.T) {
	var typ Contor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContorItem_EncodeDecode(t *testing.T) {
	var typ ContorItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContorItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevice_EncodeDecode(t *testing.T) {
	var typ Device
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Device
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDevice_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1,\"name\":\"ульпанатор 3000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Device

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Device
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDoctor_EncodeDecode(t *testing.T) {
	var typ Doctor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Doctor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDoctor_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Doctor

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Doctor
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEchographics_EncodeDecode(t *testing.T) {
	var typ Echographics
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Echographics
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEchographics_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"additional\":\"видны последстввия нездорового образа жизни\",\"conclusion\":\"требуется лечение\",\"contors\":\"контуры\",\"echogenicity\":\"эхогенность\",\"gland_volum\":100,\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"isthmus\":100,\"left_lobe_length\":100,\"left_lobe_thick\":100,\"left_lobe_volum\":100,\"left_lobe_width\":100,\"location\":\"в правой части\",\"regional_lymph\":\"в правой части\",\"right_lobe_length\":100,\"right_lobe_thick\":100,\"right_lobe_volum\":100,\"right_lobe_width\":100,\"struct\":\"квадрат\",\"vascularization\":\"выраженная\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Echographics

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Echographics
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImage_EncodeDecode(t *testing.T) {
	var typ Image
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Image
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestImage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"page\":1,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Image

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Image
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLoginPostOK_EncodeDecode(t *testing.T) {
	var typ LoginPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginPostReq_EncodeDecode(t *testing.T) {
	var typ LoginPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLoginPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"test@test.com\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ LoginPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 LoginPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMedCardDoctorIDPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedCardDoctorIDPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedCardDoctorIDPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedDoctorIDPatientsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ MedDoctorIDPatientsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedDoctorIDPatientsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientIDPatchReq_EncodeDecode(t *testing.T) {
	var typ MedPatientIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMedPatientPostReq_EncodeDecode(t *testing.T) {
	var typ MedPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MedPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessage_EncodeDecode(t *testing.T) {
	var typ Message
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Message
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMessage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"chat_id\":\"123e4567-e89b-12d3-a456-426614174001\",\"content\":\"Patient shows improvement after treatment\",\"created_at\":\"2021-01-01T00:00:00Z\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"sender_id\":\"123e4567-e89b-12d3-a456-426614174002\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Message

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Message
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNode_EncodeDecode(t *testing.T) {
	var typ Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":true,\"description\":\"узел явно неправильный\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"uzi_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Node

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Node
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNodeValidation_EncodeDecode(t *testing.T) {
	var typ NodeValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatient_EncodeDecode(t *testing.T) {
	var typ Patient
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Patient
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPatient_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"birth_date\":\"2021-01-01\",\"email\":\"ivan@example.com\",\"fullname\":\"Иван Иванов\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"last_uzi_date\":\"2024-01-01\",\"malignancy\":false,\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Patient

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Patient
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRefreshPostOK_EncodeDecode(t *testing.T) {
	var typ RefreshPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRefreshPostReq_EncodeDecode(t *testing.T) {
	var typ RefreshPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RefreshPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRefreshPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"refresh_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RefreshPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RefreshPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegDoctorPostReq_EncodeDecode(t *testing.T) {
	var typ RegDoctorPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegDoctorPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegDoctorPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"работает в медицинском центре с 2010 года\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"job\":\"Хирург\",\"org\":\"Медицинский центр\",\"password\":\"qwerty123\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegDoctorPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegDoctorPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRegPatientPostReq_EncodeDecode(t *testing.T) {
	var typ RegPatientPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegPatientPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRegPatientPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"birth_date\":\"2021-01-01\",\"email\":\"test@test.com\",\"fullname\":\"Иван Иванов\",\"password\":\"qwerty123\",\"policy\":\"1234567890\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RegPatientPostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RegPatientPostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSegment_EncodeDecode(t *testing.T) {
	var typ Segment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Segment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSegment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ai\":false,\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"image_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"node_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"tirads_23\":0.45,\"tirads_4\":0.78,\"tirads_5\":0.12}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Segment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Segment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSimpleUuid_EncodeDecode(t *testing.T) {
	var typ SimpleUuid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleUuid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSimpleUuid_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"123e4567-e89b-12d3-a456-426614174000\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SimpleUuid

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SimpleUuid
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUzi_EncodeDecode(t *testing.T) {
	var typ Uzi
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Uzi
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUzi_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"checked\":false,\"create_at\":\"2021-01-01T00:00:00Z\",\"device_id\":1,\"external_id\":\"123e4567-e89b-12d3-a456-426614174000\",\"id\":\"123e4567-e89b-12d3-a456-426614174000\",\"projection\":\"cross\",\"status\":\"pending\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Uzi

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Uzi
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostOK_EncodeDecode(t *testing.T) {
	var typ UziDevicePostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicePostReq_EncodeDecode(t *testing.T) {
	var typ UziDevicePostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicePostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziDevicePostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Siemens\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziDevicePostReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziDevicePostReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziDevicesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziDevicesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziDevicesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDImagesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDImagesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDImagesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziIDNodesGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostOK_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReq_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqNode_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDNodesSegmentsPostReqSegmentsItem_EncodeDecode(t *testing.T) {
	var typ UziIDNodesSegmentsPostReqSegmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDNodesSegmentsPostReqSegmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"checked\":true,\"projection\":\"cross\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziIDPatchReqProjection_EncodeDecode(t *testing.T) {
	var typ UziIDPatchReqProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziIDPatchReqProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziImageIDNodesSegmentsGetOK_EncodeDecode(t *testing.T) {
	var typ UziImageIDNodesSegmentsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziImageIDNodesSegmentsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziNodesIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89,\"validation\":\"invalid\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziNodesIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziNodesIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziNodesIDPatchReqValidation_EncodeDecode(t *testing.T) {
	var typ UziNodesIDPatchReqValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDPatchReqValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziNodesIDSegmentsGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UziNodesIDSegmentsGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziNodesIDSegmentsGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziProjection_EncodeDecode(t *testing.T) {
	var typ UziProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziSegmentIDPatchReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentIDPatchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentIDPatchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUziSegmentIDPatchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contor\":[{\"true\":100,\"x\":100},{\"true\":200,\"x\":200}],\"tirads_23\":0.67,\"tirads_4\":0.23,\"tirads_5\":0.89}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UziSegmentIDPatchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UziSegmentIDPatchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUziSegmentPostReq_EncodeDecode(t *testing.T) {
	var typ UziSegmentPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziSegmentPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUziStatus_EncodeDecode(t *testing.T) {
	var typ UziStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UziStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisAuthorIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisAuthorIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisAuthorIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUzisExternalIDGetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UzisExternalIDGetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UzisExternalIDGetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
